


Блок Ініціалізація

комірка тип К [парна][парна]
комірка тип О [парна][не парна] або [не парна][парна]
комірка тип Z [непарна][непарна] не використовується взагалі


Блок Заповнення

на вибір
тестування gcc(8); c++; DevC++; no optimization code; 8 threads; Win10:
	прекондітіон - масив заповнений атомами тип К і тип О, 
	паралелізація дає такі результати:
	8 потоків 	19мс для n=500
	1 потік 	28мс для n=500
	висновок: необхідності не має


Блок Еволюція.

кількість ітерація 10^9

а. rRNDCellChoose:
	. Вибір комірки О, яка заповнена елементом
	. рандомно вибираємо індекси для комірки тип О (валідна і є число -1 або 1 або 2 - маркер заповнення на вибір)
	. якщо там не має значення, продовжуємо шукати, поки не знайдемо
	. знайшли комірку з О
	
б. checkingCellOcupation: (блокуємо доступ до масиву)
	. Виділення та захоплення всіх можливих ромбів навколо вибраної комірки О
	. якщо всі індекси валідні, формуємо елемент як блок маркуємо всі індекси комірок в блоці (група ромбів) як невалідні (окрема функція)
	. якщо хочаб одна комірка вже має індекс не валідний (тобто з нею вже працюють) знімаємо статус невалідності з комірок-ромбів
	. повертаємося до процедури О
	
в. checkingJumping:
	. обчислюємо всі можливі варіанти куди може стрибнути комірка О: вертикальний ромб якщо і - не парний [0 == i%2][], горизонтальний коли і [1 == i%2][], враховуємо граничні умови (окрема функція)
	. якщо місце є вільне кидаємо в кінець черги (поки в черзі один елемент є завжди: кинули і відразу забрали - послідовне виконання поки що)
	. якщо ні знімаємо статус невалідності з комірок-ромбів (окрема функція)
	. кінець ітерації для еволюції(програма не зациклиться)
	
г. checkingPenalty (в черзі вже є один блок, тому цей крок можна паралелити)
	. обчислення пеналті для даного ромба (для двох комірок типу К суму комірок О і по результату беремо значення з таблиці Penalty) (горизонтальний чи вертикальний ромб)  (окрема функція)
	. функція вже є для однієї комірки типу К тому викликаємо двічі, щоб сформувати ромб
	. запамятовуємо індекси де ми були і фіксуємо суму двох ромбів як А
	
д. jumpingOelement
	. пробуємо стрибнути рандомно на 4 можливі місця одного ромба в рамках виділиного блока який забрали з черги
	. на новому місці може змінитися конфігурація ромба
	. рахуємо пеналті для кожної К і додаємо отримаємо нову суму пеналті = nA  (окрема функція)
	. якщо нова пеналті енергія nA менша то індекс переписується, стрибок здійснений
	. знімаємо маркери валідності з кожної комірки в рамка блока  (окрема функція)
	. кінець ітерації

е. jumpingOelementMetropolis
	. якщо нова енергія не менша за стару, перевіряємо критерій метрополіса (функція вже є)  (окрема функція)
	. якщо функціє вертає true то стрибок здійснено і переписуємо індекси комірки типу О на нове місце
	. ставимо значення в нову комірку О, що вона захоплена (я думаю, коли комірка К буде оточена 4 комірками О то ромб самозафіксується)
	. знімаємо маркери валідності з кожної комірки в рамка блока  (окрема функція)
	. кінець ітерації 
	
ж	. якщо metropolis return false
	. стрибок НЕ здійснено індекси комірки типу О повертаються на попереднє місце
	. знімаємо маркери валідності з кожної комірки в рамка блока (окрема функція)
	. кінець ітерації

з cellPainting
	. додаємо колір кожній комірці  (окрема функція)
	. всі білі
	. всі [парні][парні] обчислюємо кількість комірок типу О навколо комірки типу К
	. ставимо колір у відповідності кількості О навколо К
	. вивід у файл зображення

